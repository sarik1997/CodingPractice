âœ… WhatsApp LLD: Requirements

ğŸ”¹ Functional Requirements
	1.	One-to-one messaging (real-time)
	2.	Group chat support
	3.	Message history (persistence)
	4.	Message delivery/read receipts (âœ“âœ“)
	5.	User online/offline status

ğŸ”¹ Non-Functional Requirements
	â€¢	Scalability
	â€¢	Fault-tolerance
	â€¢	Low latency (instant delivery)
	â€¢	End-to-end encryption (optional)


	User1 â†’ send message â†’ MessageService
                      â†“
             Stored in Chat â†’ NotificationService â†’ Check User2 online
                                                            â†“
                                           If online â†’ print "Delivered"
                                           Else      â†’ simulate push


+-------------+     1          *    +-------------+
|    User     |--------------------|   Message    |
+-------------+                   +-------------+
| id          |                   | id          |
| name        |                   | content     |
| status      |                   | timestamp   |
| contacts    |                   | senderId    |
+-------------+                   | receiverId  |
                                  +-------------+

+-------------+
|   Chat      |
+-------------+
| chatId      |
| List<User>  |
| messages    |
+-------------+

+-----------------+
| MessageService  |
+-----------------+
| sendMessage()   |
| getMessages()   |
| notify()        |
+-----------------+

+-----------------+
| NotificationSvc |
+-----------------+
| deliverPush()   |
+-----------------+

We have these main classes:
	1.	User â€“ Represents a person using WhatsApp.
	2.	Message â€“ Represents a single message.
	3.	Chat â€“ A conversation between users (could be 1-1 or group).
	4.	MessageService â€“ Handles sending, storing, retrieving messages.
	5.	NotificationService â€“ Simulates real-time delivery (checks if recipient is online).

ğŸ”¹ User.java
public class User {
    private String userId;
    private String name;
    private boolean isOnline;
    private Set<String> contacts;

    public User(String id, String name) {
        this.userId = id;
        this.name = name;
        this.isOnline = false;
        this.contacts = new HashSet<>();
    }

    // getters/setters
}
ğŸ”¹ Message.java
public class Message {
    private String id;
    private String content;
    private String senderId;
    private String receiverId; // for 1-1 chat
    private long timestamp;
    private boolean delivered;
    private boolean seen;

    public Message(String id, String content, String senderId, String receiverId) {
        this.id = id;
        this.content = content;
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.timestamp = System.currentTimeMillis();
        this.delivered = false;
        this.seen = false;
    }

    // getters/setters
}
ğŸ”¹ Chat.java
public class Chat {
    private String chatId;
    private List<String> participantIds;
    private List<Message> messages;

    public Chat(String chatId, List<String> participantIds) {
        this.chatId = chatId;
        this.participantIds = participantIds;
        this.messages = new ArrayList<>();
    }

    public void addMessage(Message msg) {
        messages.add(msg);
    }

    public List<Message> getMessages() {
        return messages;
    }

    // getters
}


â¸»

â¡ï¸ Sends the message:
	â€¢	Adds it to the chat.
	â€¢	Uses NotificationService to check if recipient is online.

ğŸ”¹ MessageService.java
public class MessageService {
    private Map<String, Chat> chats = new HashMap<>();
    private NotificationService notificationService;

    public MessageService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void sendMessage(String chatId, Message message) {
        Chat chat = chats.get(chatId);
        if (chat == null) {
            System.out.println("Chat does not exist!");
            return;
        }
        chat.addMessage(message);
        notificationService.deliverMessage(message);
    }

    public List<Message> getChatHistory(String chatId) {
        Chat chat = chats.get(chatId);
        return chat == null ? Collections.emptyList() : chat.getMessages();
    }

    public void createChat(String chatId, List<String> userIds) {
        chats.put(chatId, new Chat(chatId, userIds));
    }
}



â¡ï¸ Used by MessageService to check if a message should be:
	â€¢	Delivered instantly
	â€¢	Or queued (here just simulated with a print statement)

ğŸ”¹ NotificationService.java
public class NotificationService {
    private Map<String, Boolean> userOnlineStatus = new HashMap<>();

    public void setUserOnline(String userId, boolean online) {
        userOnlineStatus.put(userId, online);
    }

    public void deliverMessage(Message message) {
        if (userOnlineStatus.getOrDefault(message.getReceiverId(), false)) {
            System.out.println("Delivered to " + message.getReceiverId() + ": " + message.getContent());
            message.setDelivered(true);
        } else {
            System.out.println("User offline. Push notification scheduled.");
        }
    }
}

â¸»

âœ… Sample Flow
NotificationService ns = new NotificationService();
MessageService ms = new MessageService(ns);

List<String> users = List.of("u1", "u2");
ms.createChat("chat1", users);

ns.setUserOnline("u2", true);

Message msg = new Message("m1", "Hello!", "u1", "u2");
ms.sendMessage("chat1", msg);
ğŸ–¨ï¸ Output:
Delivered to u2: Hello!

âœ… Extensions (for Interviews)

Feature                                 How to Add
Group chat                              Chat supports multiple participants
Seen status                             Add seen flag and seenBy set in Message
Media support                           Add attachmentUrl or MessageType enum
Encryption                              Simulate with encrypt() and decrypt() methods
Typing indicator                        Event-based user status stream
Call feature                            Add Call, CallService, status, start/end timestamps

ğŸ§  1. How would you handle message ordering?

ğŸ”¹ Problem:

Messages may arrive out of order due to network latency, retries, or server load balancing.

âœ… Solutions:
	1.	Per-chat message sequence ID:
	â€¢	Use an auto-incrementing counter per chat (or per user).
	â€¢	Store messageId = (chatId, sequenceNumber).
	2.	Timestamps with conflict resolution:
	â€¢	Use a timestamp + senderId (for tie-breakers).
	â€¢	Not ideal in distributed systems without clock sync.
	3.	Kafka-like offset:
	â€¢	Treat messages like log entries in a message queue.
	â€¢	Consumers read messages in offset order.

âœ… At storage and UI, always sort messages based on this sequence.

â¸»

ğŸ§  2. How would you scale this for 10M users?

âœ… Techniques:
	1.	Sharded Databases:
	â€¢	Shard users or chats across multiple DB partitions by userId % N.
	2.	Microservices:
	â€¢	Split into services: UserService, ChatService, MessageService, NotificationService.
	3.	WebSocket clusters:
	â€¢	Use load balancers + WebSocket gateway servers (each maintaining active connections).
	â€¢	Sticky sessions or centralized pub/sub (e.g., Redis) for routing.
	4.	Horizontal scaling:
	â€¢	Stateless services behind a load balancer (Kubernetes, ECS).
	â€¢	Scale out based on message rate.
	5.	Caching:
	â€¢	Use Redis or Memcached for user presence, recent chats.

â¸»

ğŸ§  3. How would you design this in a distributed architecture?

âœ… High-level Components:
[Client]
   â†“ WebSocket/HTTP
[API Gateway]
   â†“
[Message Router] â€”â†’ [Notification Service]
   â†“
[Chat Service] â€”â†’ DB
   â†“
[Message Queue (Kafka/SQS)]
   â†“
[Message Processor]

âœ… Key Points:
	â€¢	WebSockets for real-time updates.
	â€¢	Message Broker (e.g., Kafka) decouples producers and consumers.
	â€¢	Distributed Cache (e.g., Redis) for presence and unread counts.
	â€¢	Storage Service writes to durable storage (Cassandra, DynamoDB).
	â€¢	Replica Databases for read scaling.

â¸»

ğŸ§  4. How would you ensure message durability (no loss)?

âœ… Solutions:
	1.	Persistent Queue:
	â€¢	Use Kafka or RabbitMQ (durable mode).
	â€¢	Messages are persisted even if consumer is down.
	2.	Acknowledgment before delete:
	â€¢	Only delete from queue once itâ€™s acknowledged by receiver or delivery service.
	3.	Write-ahead logs:
	â€¢	Append messages to a durable log before storing in DB.
	4.	Database replication & backups:
	â€¢	Use multi-AZ, multi-region DB with replication (Cassandra/DynamoDB).
	5.	Retry queue for failed deliveries.

ğŸ’¡ WhatsApp uses a mix of XMPP, custom protocols, and delivery queues with retry logic.

â¸»

ğŸ§  5. How would you handle retries and acknowledgments?

âœ… Concept: Reliable delivery protocol
	1.	ACK mechanism:
	â€¢	Client sends an acknowledgment when message is received/displayed.
	â€¢	Server updates message status: Sent â†’ Delivered â†’ Seen.
	2.	Retry queue:
	â€¢	Undelivered messages are stored in a retry buffer.
	â€¢	Retry on intervals with exponential backoff.
	3.	Idempotent delivery:
	â€¢	Every message has a unique ID.
	â€¢	Even if retried, the server/client knows not to duplicate it.
	4.	Dead-letter queue:
	â€¢	Messages that fail delivery after N retries are moved to a special queue for debugging or manual recovery.


Question                                        Strategy
Message Ordering                    Use sequence number per chat or offset-based queue
10M User Scale                      Sharding, load balancing, microservices, cache
Distributed Design                  WebSockets, Kafka, storage service, message router
Durability                          Persist queues, ACKs, replication, logs
Retry & ACK                         Retry buffer, exponential backoff, idempotent messages

