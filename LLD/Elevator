Designing an Elevator System is a classic LLD (Low-Level Design) interview question â€” asked frequently at ServiceNow and other product-based companies â€” to assess your:
	â€¢	Object-Oriented Design (OOD) skills
	â€¢	Understanding of state machines, concurrency, and scalability
	â€¢	Ability to break large systems into modular components

â¸»

âœ… Problem Statement

Design a software system for a multi-floor elevator system with:
	â€¢	Multiple elevators
	â€¢	Each elevator can move up/down
	â€¢	Users can request from any floor to go up/down
	â€¢	Elevators must handle internal and external requests
	â€¢	The system must assign elevators intelligently

â¸»

âœ… Key OOP Concepts to Use
	â€¢	Encapsulation â€“ model elevators as objects
	â€¢	Inheritance/Polymorphism â€“ if you have different elevator types (e.g., service elevator)
	â€¢	State Pattern / Enum â€“ to model elevator states
	â€¢	Queueing/Scheduling â€“ for managing requests

â¸»

âœ… Class Diagram Overview

+--------------------+
| ElevatorSystem     |
+--------------------+
| - elevators: List<Elevator> |
| + requestPickup(int floor, Direction dir) |
| + step()           |
+--------------------+

+--------------+
| Elevator     |
+--------------+
| - id: int    |
| - currentFloor: int |
| - direction: Direction |
| - state: ElevatorState |
| - requests: TreeSet<Integer> |
| + step()     |
| + addRequest(int floor) |
+--------------+

+------------------+
| enum Direction   |
+------------------+
| UP, DOWN, IDLE   |
+------------------+

+---------------------+
| enum ElevatorState  |
+---------------------+
| MOVING, IDLE, DOORS_OPEN |
+---------------------+

âœ… Overall Concept

Weâ€™re simulating a system where:
	â€¢	There are multiple elevators.
	â€¢	People from different floors can request an elevator.
	â€¢	Each elevator:
	â€¢	Knows its current floor.
	â€¢	Has a direction (UP, DOWN, IDLE).
	â€¢	Maintains a queue of floors to stop at.
	â€¢	Moves one floor at a time per step.
	â€¢	Stops and serves the request at the correct floor.

The main components are:
	â€¢	ElevatorSystem: manages all elevators.
	â€¢	Elevator: individual elevator with state and logic.
	â€¢	Enums: Direction and ElevatorState.


Used to represent the direction in which an elevator is moving.
ðŸ”¹ Direction.java
public enum Direction {
    UP, DOWN, IDLE
}

Represents the status of the elevator:
	â€¢	IDLE: doing nothing.
	â€¢	MOVING: traveling up/down.
	â€¢	DOORS_OPEN: stopped to pick/drop someone.

ðŸ”¹ ElevatorState.java
public enum ElevatorState {
    IDLE, MOVING, DOORS_OPEN
}

ðŸ”¹ Elevator.java
import java.util.TreeSet;

public class Elevator {
    private int id;
    private int currentFloor;
    private Direction direction;
    private ElevatorState state;
    private TreeSet<Integer> requests; // Sorted floor requests

    public Elevator(int id) {
        this.id = id;
        this.currentFloor = 0;
        this.direction = Direction.IDLE;
        this.state = ElevatorState.IDLE;
        this.requests = new TreeSet<>();
        ///////
        	â€¢	Initializes elevator on floor 0
        	â€¢	Keeps it idle and empty (no requests yet)

    }

//	â€¢	Adds the requested floor to the elevatorâ€™s queue.
  	â€¢	If the elevator is idle, sets direction and starts moving.
///////////
    public void addRequest(int floor) {
        requests.add(floor);
        if (state == ElevatorState.IDLE) {
            direction = floor > currentFloor ? Direction.UP : Direction.DOWN;
            state = ElevatorState.MOVING;
        }
    }

/////////////
	1.	If there are no requests, go idle.
	2.	Otherwise, find the next target floor based on the direction:
	â€¢	ceiling(floor): smallest floor â‰¥ current (for UP)
	â€¢	floor(floor): largest floor â‰¤ current (for DOWN)
	////////////
    public void step() {
        if (requests.isEmpty()) {
            direction = Direction.IDLE;
            state = ElevatorState.IDLE;
            return;
        }

        Integer target = direction == Direction.UP ? requests.ceiling(currentFloor) : requests.floor(currentFloor);
        if (target == null) target = requests.first();
//////////
	3.	If at the target floor â†’ open door and remove the request.
	4.	Else â†’ move up/down one floor.
	///////////
        if (currentFloor == target) {
            System.out.println("Elevator " + id + " stopped at floor " + currentFloor);
            requests.remove(currentFloor);
            state = ElevatorState.DOORS_OPEN;
        } else {
            currentFloor += direction == Direction.UP ? 1 : -1;
            System.out.println("Elevator " + id + " moving " + direction + " to floor " + currentFloor);
            state = ElevatorState.MOVING;
        }
    }

    public boolean isIdle() {
        return state == ElevatorState.IDLE && requests.isEmpty();
    }

    public int getCurrentFloor() {
        return currentFloor;
    }

    public Direction getDirection() {
        return direction;
    }

    public int getId() {
        return id;
    }
}

ðŸ”¹ ElevatorSystem.java
import java.util.*;

public class ElevatorSystem {
    private List<Elevator> elevators;

    public ElevatorSystem(int numberOfElevators) {
        elevators = new ArrayList<>();
        //Initializes a list of elevators.
        for (int i = 0; i < numberOfElevators; i++) {
            elevators.add(new Elevator(i));
        }
    }
//	â€¢	When someone presses the elevator button on a floor, this method:
  	1.	Tries to find an IDLE elevator.
  	2.	If none found, assigns a default elevator (for simplicity).
  	3.	Adds the floor to the selected elevatorâ€™s request queue.
///////////////////////////
    public void requestPickup(int floor, Direction direction) {
        Elevator bestElevator = null;

        for (Elevator e : elevators) {
            if (e.isIdle()) {
                bestElevator = e;
                break;
            }
        }

        if (bestElevator == null) {
            // fallback: random or nearest
            bestElevator = elevators.get(0);
        }

        System.out.println("Assigned Elevator " + bestElevator.getId() + " to floor " + floor);
        bestElevator.addRequest(floor);
    }

    public void step() {
        for (Elevator e : elevators) {
            e.step();
        }
    }
}

ðŸ”¹ Main.java (Test Runner)
public class Main {
    public static void main(String[] args) throws InterruptedException {
        ElevatorSystem system = new ElevatorSystem(2);

        system.requestPickup(3, Direction.UP);
        system.requestPickup(5, Direction.DOWN);
        system.requestPickup(7, Direction.DOWN);

        for (int i = 0; i < 10; i++) {
            system.step();
            Thread.sleep(1000); // Simulate 1 second steps
        }
    }
}
Assigned Elevator 0 to floor 3
Assigned Elevator 1 to floor 5
Assigned Elevator 0 to floor 7
Elevator 0 moving UP to floor 1
Elevator 1 moving UP to floor 1
...
Elevator 0 stopped at floor 3
Elevator 1 stopped at floor 5
...



Design Choice                       Why?
TreeSet for requests            Keeps floors sorted automatically
Direction & State Enums         Clear finite-state-machine style transitions
step()                              Allows discrete time simulation (clean and testable)
ElevatorSystem assigns elevators    Separation of responsibility

ðŸš€ Bonus Enhancements (Advanced Topics)
	â€¢	Use PriorityQueue for nearest elevator scheduling
	â€¢	Track passenger count or weight limit
	â€¢	Add UI interaction class for button presses
	â€¢	Implement a real-time simulator

	1.	ðŸšª What if someone inside wants to go to a different floor?
    	â€¢	Support internal buttons, add those to the same requests set.
    	2.	ðŸ§  How to assign elevators better?
    	â€¢	Use priority queue based on proximity, load balancing, or predicted paths.
    	3.	ðŸš¨ What if an elevator breaks?
    	â€¢	Add a status field and remove it from assignment pool.