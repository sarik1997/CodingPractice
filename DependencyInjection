Dependency Injection (DI) - Explained

Dependency Injection (DI) is a design pattern used to implement the Dependency Inversion Principle (DIP).
It allows a class to receive its dependencies from an external source, rather than creating them internally.

Why Use Dependency Injection?

Problems Without DI

If a class creates its own dependencies, it leads to:
‚ùå Tight Coupling ‚Äì Hard to replace dependencies.
‚ùå Difficult Testing ‚Äì Cannot mock dependencies easily.
‚ùå Hard to Extend ‚Äì Need to modify existing code for changes.

Solution? ‚úÖ Use Dependency Injection to pass dependencies externally rather than creating them inside the class.
‚∏ª
Types of Dependency Injection in Java
	1.	Constructor Injection (Recommended)
	2.	Setter Injection
	3.	Field Injection
‚∏ª
1. Constructor Injection (Best Practice)

üîπ Injects dependencies via the constructor.
üîπ Ensures immutability (dependencies cannot change after object creation).
üîπ Recommended for mandatory dependencies.

Example Without DI (Bad)
class MySQLDatabase {
    void connect() {
        System.out.println("Connected to MySQL Database");
    }
}

class OrderService {
    private MySQLDatabase db = new MySQLDatabase(); // Bad: Tight Coupling

    void processOrder() {
        db.connect();
        System.out.println("Processing order...");
    }
}

‚ùå Tightly coupled ‚Üí OrderService cannot use another database without modifying code.
‚ùå Hard to test ‚Üí Cannot inject a mock database.

Fixed Using Constructor Injection (Good)

interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() {
        System.out.println("Connected to MySQL Database");
    }
}

class PostgreSQLDatabase implements Database {
    public void connect() {
        System.out.println("Connected to PostgreSQL Database");
    }
}

// Injecting dependency via Constructor (Best Practice)
class OrderService {
    private final Database db;

    public OrderService(Database db) { // Dependency Injection
        this.db = db;
    }

    void processOrder() {
        db.connect();
        System.out.println("Processing order...");
    }
}

public class Main {
    public static void main(String[] args) {
        Database mysql = new MySQLDatabase();
        OrderService orderService = new OrderService(mysql); // Inject MySQL

        orderService.processOrder();

        Database postgres = new PostgreSQLDatabase();
        OrderService anotherService = new OrderService(postgres); // Inject PostgreSQL

        anotherService.processOrder();
    }
}

‚úÖ Loose coupling ‚Äì Can switch databases easily.
‚úÖ Better testability ‚Äì We can inject a mock database.
‚úÖ More maintainable ‚Äì No need to modify OrderService to change the database.

‚∏ª
2. Setter Injection

üîπ Injects dependencies via setter methods.
üîπ Useful for optional dependencies.
üîπ Allows changing dependencies at runtime.

class OrderService {
    private Database db;

    public void setDatabase(Database db) { // Setter Injection
        this.db = db;
    }

    void processOrder() {
        if (db == null) {
            System.out.println("No database set!");
            return;
        }
        db.connect();
        System.out.println("Processing order...");
    }
}

public class Main {
    public static void main(String[] args) {
        OrderService orderService = new OrderService();
        orderService.setDatabase(new MySQLDatabase()); // Injecting dependency
        orderService.processOrder();
    }
}
‚úÖ Flexible ‚Äì Can change dependencies at runtime.
‚ùå Allows null values ‚Äì Risk of NullPointerException if not set.

‚∏ª

3. Field Injection (Avoid if Possible)

üîπ Uses @Autowired in Spring to inject dependencies directly into fields.
üîπ Not recommended for mandatory dependencies because it hides dependencies.
class OrderService {
    @Autowired // Spring will automatically inject the dependency
    private Database db;

    void processOrder() {
        db.connect();
        System.out.println("Processing order...");
    }
}

‚ùå Not recommended for non-Spring applications.
‚ùå Hidden dependencies ‚Äì No way to know required dependencies from the constructor.

‚∏ª

Dependency Injection in Spring Boot

Using Spring Framework to Inject Dependencies

Spring Boot manages dependencies using @Component, @Service, @Repository, and @Autowired.

Step 1: Define the Dependency

import org.springframework.stereotype.Component;

@Component
class MySQLDatabase implements Database {
    public void connect() {
        System.out.println("Connected to MySQL Database");
    }
}
Step 2: Inject the Dependency into a Service

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
class OrderService {
    private final Database db;

    @Autowired // Spring injects the dependency
    public OrderService(Database db) {
        this.db = db;
    }

    public void processOrder() {
        db.connect();
        System.out.println("Processing order...");
    }
}
Step 3: Run Spring Boot Application
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Main.class, args);

        OrderService orderService = context.getBean(OrderService.class);
        orderService.processOrder();
    }
}
‚úÖ Spring automatically injects dependencies.
‚úÖ No need to manually instantiate objects.

‚∏ª

When to Use Each Injection Type?
Type                                   Best Use Case                       Pros                           Cons
Constructor Injection (Recommended)   Required dependencies      Ensures immutability, easy testing    More boilerplate
Setter Injection                      Optional dependencies      More flexibility                     Allows null values
Field Injection                       Spring Boot applications   Less code                    Hard to test, hidden dependencies


Final Takeaways

‚úÖ Dependency Injection reduces tight coupling and makes code flexible, testable, and maintainable.
‚úÖ Constructor Injection is best for required dependencies.
‚úÖ Spring Boot makes DI easier with @Autowired and @Component annotations.
