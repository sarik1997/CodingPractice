To update

To set a columnâ€™s value as 'Not Available' when it is NULL, you can use SQL queries with either:
	â€¢	UPDATE statements to permanently change the data in the table
	â€¢	SELECT statements with conditional expressions like COALESCE() or CASE to show default values without changing the data

â¸»

ðŸ”§ 1. UPDATE Query â€“ Permanently replace NULL with 'Not Available'
UPDATE your_table
SET column_name = 'Not Available'
WHERE column_name IS NULL;

ðŸ‘€ 2. SELECT Query â€“ Show 'Not Available' for NULL values (without changing the table)

Option A: Using COALESCE()
SELECT COALESCE(column_name, 'Not Available') AS column_name FROM your_table;
SELECT id, name, COALESCE(email, 'Not Available') AS email FROM customers;

Option B: Using CASE
SELECT
  CASE
    WHEN column_name IS NULL THEN 'Not Available'
    ELSE column_name
  END AS column_name
FROM your_table;


In SQL (across major databases like MySQL, PostgreSQL, Oracle, SQL Server),
indexes are special data structures that improve the speed of data retrieval operations.
 There are several types of indexes, each suited to different use cases.

â¸»

ðŸ” Types of Indexing in SQL

1. Single-column Index
	â€¢	Created on a single column.
	â€¢	Improves search and filter performance on that column.
	CREATE INDEX idx_name ON employees(last_name);

2. Composite (Multi-column) Index
	â€¢	Indexes multiple columns together.
	â€¢	Only efficient when queries filter using the left-most columns.
	CREATE INDEX idx_emp_dept ON employees(department_id, last_name);

3. Unique Index
	â€¢	Ensures all values in the indexed column(s) are unique.
	â€¢	Automatically created for primary keys and unique constraints.
	CREATE UNIQUE INDEX idx_email_unique ON users(email);

4. Full-text Index
	â€¢	Used for text searching (e.g., searching for words or phrases).
	â€¢	Supported in MySQL (FULLTEXT), PostgreSQL (via tsvector), etc.
	-- MySQL
    CREATE FULLTEXT INDEX idx_desc_fulltext ON articles(description);

 5. Spatial Index
 	â€¢	Used for indexing geographic data (GIS types).
 	â€¢	Available in databases like MySQL, PostgreSQL (PostGIS), Oracle Spatial.
 	-- MySQL (on geometry column)
    CREATE SPATIAL INDEX idx_location ON maps(location);
    ETC....


    A SQL â€œjoinâ€ is an operation that combines data from two or more tables based on a related column,
    allowing richer and more meaningful results from relational databases.
    Types of SQL Joins
    	â€¢	INNER JOIN: Returns only the rows where there is a match in both tables for the specified columns.
    	â€¢	LEFT JOIN (LEFT OUTER JOIN): Returns all rows from the left table, plus matched rows from the right table. Unmatched rows from the right table show as NULL.
    	â€¢	RIGHT JOIN (RIGHT OUTER JOIN): Returns all rows from the right table, plus matched rows from the left table. Unmatched rows from the left table show as NULL.
    	â€¢	FULL JOIN (FULL OUTER JOIN): Returns all rows from both tables. Where thereâ€™s no match, NULLs fill the gaps.
    	â€¢	CROSS JOIN: Produces a Cartesian productâ€”every row from the first table is paired with every row from the second table. Useful for generating all possible combinations.
    	â€¢	SELF JOIN: Joins a table to itself, often used for hierarchical or recursive relationships, such as employees and their managers within an Employee table.
    Typical Example
    Suppose a â€œStudentâ€ table contains student details, and a â€œMarksâ€ table associates marks with student IDs. An INNER JOIN on the ID lets you see each student with their marks in one result set, only showing students who have marks recorded.
    Syntax Example
SELECT a.Name, b.Marks FROM Student a INNER JOIN Marks b ON a.ID = b.StudentID;
////////// Third highest Salary
SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 2;

SELECT Salary FROM ( SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 3) AS temp ORDER BY Salary ASC LIMIT 1;

SELECT * FROM ( SELECT emp_name, Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS rnk FROM Employee) AS ranked WHERE rnk = 3;


////////The query to get the average of the highest salaries by department for employees who joined after 2021 could look like this:
SELECT d.dept_name, AVG(highest_salary) AS avg_high_salary
FROM (
    SELECT e.dept_id, MAX(s.salary_amount) AS highest_salary
    FROM employee e
    JOIN salary s ON e.employee_id = s.employee_id
    WHERE e.join_date > '2021-12-31'
    GROUP BY e.dept_id
) AS dept_highest_salaries
JOIN department d ON d.dept_id = dept_highest_salaries.dept_id
GROUP BY d.dept_name;


Select standard ,subject from student Group By Standard,subject Havibg MIN(marks)>70;


