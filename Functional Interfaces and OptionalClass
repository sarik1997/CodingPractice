Functional Interface in Java (Java 8+)

A functional interface in Java is an interface that has exactly one abstract method. It can have multiple default or static methods but only one abstract method.

üí° Key Use: Functional interfaces are used in lambda expressions and method references to provide clean, concise, and readable code.

‚∏ª

1Ô∏è‚É£ Functional Interface Example
@FunctionalInterface
interface MyFunctionalInterface {
    void show(); // Single abstract method
}

public class Main {
    public static void main(String[] args) {
        // Using Lambda Expression
        MyFunctionalInterface obj = () -> System.out.println("Hello from Functional Interface!");
        obj.show(); // Output: Hello from Functional Interface!
    }
}

üëâ Lambda expressions work with functional interfaces because they have only one abstract method.

‚∏ª

2Ô∏è‚É£ @FunctionalInterface Annotation
	‚Ä¢	@FunctionalInterface is optional but recommended.
	‚Ä¢	It ensures the interface has only one abstract method.
	‚Ä¢	If you add a second abstract method, the compiler throws an error.

	@FunctionalInterface
    interface Demo {
        void display(); // Only one abstract method allowed

        default void sayHello() {
            System.out.println("Hello from default method!");
        }
    }

    ‚úÖ Allowed: Default methods do not break functional interface rules.

    üö® Not Allowed:
    @FunctionalInterface
    interface InvalidInterface {
        void method1();
        void method2(); // ‚ùå Compilation Error (More than one abstract method)
    }
3Ô∏è‚É£ Predefined Functional Interfaces in Java (java.util.function)

Java provides several built-in functional interfaces in the java.util.function package.

‚úî Predicate<T> ‚Äì Takes an input and returns true or false
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<Integer> isEven = num -> num % 2 == 0;
        System.out.println(isEven.test(10)); // Output: true
        System.out.println(isEven.test(5));  // Output: false
    }
}

‚úî Function<T, R> ‚Äì Takes an input and returns a result

import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Integer> lengthFunction = str -> str.length();
        System.out.println(lengthFunction.apply("Java")); // Output: 4
    }
}

‚úî Consumer<T> ‚Äì Takes an input and returns nothing

import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<String> printConsumer = msg -> System.out.println("Message: " + msg);
        printConsumer.accept("Hello, Functional Interfaces!"); // Output: Message: Hello, Functional Interfaces!
    }
}

‚úî Supplier<T> ‚Äì Takes nothing and returns a value
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        Supplier<Double> randomSupplier = () -> Math.random();
        System.out.println(randomSupplier.get()); // Output: Random number
    }
}

Feature                          Functional Interface                                  Normal Interface
Abstract Methods                   Exactly one                                          Can have multiple
Default Methods                     Allowed                                             Allowed
Static Methods                      Allowed                                             Allowed
Lambda Expression Support           Yes                                                 No


5Ô∏è‚É£ Summary

‚úÖ A functional interface has one abstract method and can have multiple default/static methods.
‚úÖ The @FunctionalInterface annotation ensures it remains a functional interface.
‚úÖ Lambda expressions work with functional interfaces to simplify code.
‚úÖ Java provides predefined functional interfaces like Predicate, Function, Consumer, and Supplier.







The Optional class in Java (introduced in Java 8) is a container object that may or may not contain a non-null value.
 It helps avoid NullPointerException by forcing developers to handle the absence of a value explicitly.

 1Ô∏è‚É£ Why Use Optional?

 Before Java 8, developers relied on null checks to avoid NullPointerException:
 public String getName(Person person) {
     if (person != null) {
         return person.getName();
     } else {
         return "Unknown";
     }
 }

 üí° Problem: If we forget the null check, calling person.getName() on null would cause a crash.

 With Optional, we can make the absence of a value explicit:
 public Optional<String> getName(Person person) {
     return Optional.ofNullable(person.getName());
 }

 Now, the caller must handle the possibility of an empty value, reducing NullPointerException risk.

 ‚∏ª

 2Ô∏è‚É£ Creating an Optional Instance

 There are three ways to create an Optional:

 ‚úî Optional.of(value) ‚Üí Throws an exception if value is null
 Optional<String> optional = Optional.of("Hello");
 System.out.println(optional.get()); // Output: Hello
 üö® Warning: If you pass null, it will throw NullPointerException:
 Optional<String> optional = Optional.of(null); // ‚ùå Throws NullPointerException

‚∏ª

‚úî Optional.ofNullable(value) ‚Üí Allows null values
Optional<String> optional = Optional.ofNullable(null);
System.out.println(optional.isPresent()); // Output: false

‚úÖ If the value is null, it returns an empty Optional.

‚∏ª

‚úî Optional.empty() ‚Üí Represents an empty Optional
Optional<String> optional = Optional.empty();
System.out.println(optional.isPresent()); // Output: false


‚∏ª

3Ô∏è‚É£ Checking If a Value is Present

‚úî isPresent() ‚Üí Returns true if value exists
Optional<String> optional = Optional.of("Java");
System.out.println(optional.isPresent()); // Output: true

‚úî ifPresent(Consumer<T>) ‚Üí Executes a function if a value is present
Optional<String> optional = Optional.of("Java");

optional.ifPresent(value -> System.out.println("Value: " + value));
// Output: Value: Java

üí° Benefit: No need for explicit null checks.

‚∏ª

4Ô∏è‚É£ Retrieving Values from Optional

‚úî get() ‚Üí Returns the value (‚ö†Ô∏è Unsafe, use with caution)

Optional<String> optional = Optional.of("Java");
System.out.println(optional.get()); // Output: Java

üö® ‚ö†Ô∏è If Optional is empty, calling get() throws NoSuchElementException.
Optional<String> emptyOptional = Optional.empty();
System.out.println(emptyOptional.get()); // ‚ùå Throws NoSuchElementException

üëâ Best Practice: Use orElse(), orElseGet(), or orElseThrow() instead.

‚∏ª

‚úî orElse(T other) ‚Üí Returns a default value if empty
Optional<String> optional = Optional.empty();
String value = optional.orElse("Default Value");
System.out.println(value); // Output: Default Value

‚úî orElseGet(Supplier<T>) ‚Üí Uses a supplier for default value
 Optional<String> optional = Optional.empty();
 String value = optional.orElseGet(() -> "Generated Value");
 System.out.println(value); // Output: Generated Value

üí° Difference between orElse() and orElseGet()
	‚Ä¢	orElse() always evaluates the default value.
	‚Ä¢	orElseGet() only evaluates the default value when needed (better performance).

‚∏ª

‚úî orElseThrow(Supplier<Exception>) ‚Üí Throws an exception if empty
Optional<String> optional = Optional.empty();
String value = optional.orElseThrow(() -> new RuntimeException("Value not found"));
System.out.println(value); // ‚ùå Throws RuntimeException

5Ô∏è‚É£ Transforming and Filtering Optional Values

‚úî map(Function<T, R>) ‚Üí Transforms the value

Optional<String> optional = Optional.of("java");

Optional<String> upperCaseOptional = optional.map(String::toUpperCase);
System.out.println(upperCaseOptional.get()); // Output: JAVA

üöÄ If the Optional is empty, map() returns an empty Optional.

‚∏ª

‚úî flatMap(Function<T, Optional<R>>) ‚Üí Avoids nested Optional<Optional<T>>

Optional<Optional<String>> nestedOptional = Optional.of(Optional.of("Java"));

Optional<String> result = nestedOptional.flatMap(o -> o);
System.out.println(result.get()); // Output: Java


‚∏ª

‚úî filter(Predicate<T>) ‚Üí Returns the value if it matches a condition
Optional<Integer> number = Optional.of(10);

Optional<Integer> filteredNumber = number.filter(n -> n > 5);
System.out.println(filteredNumber.isPresent()); // Output: true

Optional<Integer> emptyResult = number.filter(n -> n > 20);
System.out.println(emptyResult.isPresent()); // Output: false

6Ô∏è‚É£ ifPresentOrElse() ‚Äì Java 9+

If the value is present, execute Consumer<T>. Otherwise, execute Runnable.
Optional<String> optional = Optional.empty();

optional.ifPresentOrElse(
    value -> System.out.println("Value: " + value),
    () -> System.out.println("No value found")
);
// Output: No value found

7Ô∏è‚É£ stream() ‚Äì Java 9+

Converts an Optional into a Stream.
Optional<String> optional = Optional.of("Java");
optional.stream().forEach(System.out::println);
// Output: Java

üéØ Summary
Method                                              Description
of(T value)                                         Creates an Optional, throws NullPointerException if null.
ofNullable(T value)                                 Creates an Optional, allows null.
empty()                                             Returns an empty Optional.
isPresent()                                         Checks if a value is present.
ifPresent(Consumer<T> action)                       Executes an action if value is present.
get()                                               Retrieves the value (throws exception if empty).
orElse(T other)                                     Returns a default value if empty.
orElseGet(Supplier<T>)                              Uses a supplier for the default value.
orElseThrow(Supplier<Exception>)                    Throws an exception if empty.
map(Function<T, R>)                                 Transforms the value if present.
flatMap(Function<T, Optional<R>>)                   Avoids nested Optional<Optional<T>>.
filter(Predicate<T>)                                Returns value if it matches a condition.
ifPresentOrElse(Consumer<T>, Runnable)              Runs an action for both present and empty cases.
stream()                                            converts Optional to a Stream (Java 9+).

üéØ When to Use Optional?

‚úÖ Use Optional when:
	‚Ä¢	You return a value that may be absent.
	‚Ä¢	You want to avoid null checks.
	‚Ä¢	You need to enforce proper handling of missing values.

‚ùå Don‚Äôt use Optional:
	‚Ä¢	As method parameters (Optional is meant for return values).
	‚Ä¢	For fields in entities or DTOs (use null instead).

